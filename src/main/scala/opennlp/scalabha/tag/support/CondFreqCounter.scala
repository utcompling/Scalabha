package opennlp.scalabha.tag.support

import opennlp.scalabha.util.CollectionUtils._
import opennlp.scalabha.util.Pattern
import opennlp.scalabha.util.Probability
import opennlp.scalabha.util.Probability._

/**
 * A builder for conditional frequency distributions.  Stores counts (in a mutable
 * fashion) and allows counts to be added.  A distribution based on the
 * counts is generated by calling 'toFreqDist'.
 *
 * This is the top of a hierarchy designed for a modular approach to
 * frequency distribution building.  SimpleCondFreqCounter serves as the basic
 * form of the counter; it stores and increments the actual counts.  Other
 * implementations of CondFreqCounter will be count-transforming decorators
 * extending DelegatingCondFreqCounter that wrap SimpleCondFreqCounter or wrap
 * wrappers thereof.  Multiple layers of decoration allow various
 * transformations to be applied to the counts, and in varying orders.
 *
 * The operation of the system is such that counts, when added via the
 * top-most layer are passed, untouched, all the way to the base where they
 * are stored.  When toFreqDist is called, the counts are gathered via
 * recursive calls to resultCounts that travel down the layers to the bottom,
 * where the true counts are retrieved.  Each layer, starting from the bottom,
 * then applies its transformation and returns the modified counts to be
 * received by the higher layers.  Once the (modified) counts reach the top,
 * they are used to calculate the distribution.
 *
 * For example, the following code will create a CondFreqCounter that, before
 * creating a distribution, will constrain its counts to those in validEntries
 * and then smooth the constrained counts:
 * {{{
 *   new SimpleSmoothingCondFreqCounter(lambda,
 *     new ConstrainingCondFreqCounter(validEntries, strict,
 *       new SimpleCondFreqCounter()))
 * {{{
 *
 * Implementing classes should define:
 * <ul>
 *   <li> increment: Add to counts. Should simply forward to delegate.
 *   <li> resultCounts: Apply transformation to delegate's resultCounts.
 * </ul>
 *
 * @tparam A	the conditioning item being counted; P(B|A).
 * @tparam B	the conditioned item being counted; P(B|A).
 */
abstract class CondFreqCounter[A, B] {
  def increment(a: A, b: B, n: Double)
  def resultCounts(): (Map[A, (Map[B, Double], Double, Double)], Double, Double)

  final def ++=(other: CondFreqCounts[A, B, Double]): CondFreqCounter[A, B] = { other.iterator.foreach { case (a, bs) => bs.iterator.foreach { case (b, n) => increment(a, b, n) } }; this }
  final def ++=(other: CondFreqCounter[A, B]): CondFreqCounter[A, B] = this ++= CondFreqCounts(other.resultCounts._1.mapValuesStrict(_._1))
  final def ++=(other: TraversableOnce[(A, B)]): CondFreqCounter[A, B] = this ++= new CondFreqCounts(other.toIterator.groupByKey.mapValuesStrict(m => new FreqCounts(m.counts.mapValuesStrict(_.toDouble))))

  final def toFreqDist: A => B => Probability = {
    CondFreqDist(resultCounts())
  }
}

object CondFreqCounter {
  /**
   * Easily construct structured counter.
   *
   * apply("smooth" -> lambda, "const" -> grammar) => will smooth constrained counts
   * apply("const" -> grammar, "smooth" -> lambda) => will constrain smoothed counts
   */
  def apply[A, B](options: (String, Any)*) = {
    options.foldRight(new SimpleCondFreqCounter[A, B](): CondFreqCounter[A, B]) {
      case ((k, v), delegate) =>
        if (k.startsWith("smooth")) v match {
          case Pattern.Double(lambda) => new SimpleSmoothingCondFreqCounter(lambda, delegate)
        }
        else if (k.startsWith("const")) v match {
          case (grammar: Map[A, Set[B]], strict: Boolean) => ConstrainingCondFreqCounter(grammar, strict, delegate)
          case (grammar: Option[Map[A, Set[B]]], strict: Boolean) => ConstrainingCondFreqCounter(grammar, strict, delegate)
        }
        else throw new MatchError("could not match '%s'".format(k))
    }
  }
}

//////////////////////////////////////
// Base Implementation
//////////////////////////////////////

/**
 * The base CondFreqCounter implementation that directly stores and updates a
 * (mutable) map of counts.
 */
class SimpleCondFreqCounter[A, B] extends CondFreqCounter[A, B] {
  private val storedCounts = collection.mutable.Map[A, FreqCounter[B]]()
  override def increment(a: A, b: B, n: Double) { storedCounts.getOrElseUpdate(a, new SimpleFreqCounter[B]).increment(b, n) }
  override def resultCounts() = (storedCounts.toMap.mapValuesStrict(_.resultCounts), 0, 0)
  override def toString = storedCounts.mapValues(_.toString).toString
}

//////////////////////////////////////
// Delegating Implementation
//////////////////////////////////////

/**
 * The base CondFreqCounter decorator.  It handles the counter incrementing,
 * so subclasses need only implement resultCounts.
 *
 * @param delegate	the delegate counter upon which the transformation is performed
 */
abstract class DelegatingCondFreqCounter[A, B](delegate: CondFreqCounter[A, B]) extends CondFreqCounter[A, B] {
  final override def increment(a: A, b: B, n: Double) { delegate.increment(a, b, n) }
}

//////////////////////////////////////
// Constraining Implementation
//////////////////////////////////////

/**
 * CondFreqCounter decorator that zero out counts for entries not found in
 * validEntries.
 *
 * @param validEntries	zero out entries not found in this set
 * @param strict	if true, default information will be zeroed as well
 * @param delegate	the delegate counter upon which the transformation is performed
 */
class ConstrainingCondFreqCounter[A, B](validBigrams: Map[A, Set[B]], strict: Boolean, delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {
  override def resultCounts() = {
    val (delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = delegate.resultCounts
    val filteredResultCounts =
      for ((a, (aCounts, aTotalAdd, aDefault)) <- delegateResultCounts) yield {
        val filtered = validBigrams.get(a).map(aCounts.filterKeys).getOrElse(Map())
        val totalAdd = if (strict) 0 else aTotalAdd
        val default = if (strict) 0 else aDefault
        (a, (filtered, totalAdd, default))
      }
    val totalAddition = if (strict) 0 else delegateTotalAddition
    val defaultCount = if (strict) 0 else delegateDefaultCount
    (filteredResultCounts, delegateTotalAddition, delegateDefaultCount)
  }
}

object ConstrainingCondFreqCounter {
  def apply[A, B](validEntries: Map[A, Set[B]], strict: Boolean, delegate: CondFreqCounter[A, B]) =
    new ConstrainingCondFreqCounter(validEntries, strict, delegate)
  def apply[A, B](validEntries: Option[Map[A, Set[B]]], strict: Boolean, delegate: CondFreqCounter[A, B]) =
    validEntries match {
      case Some(validEntries) => new ConstrainingCondFreqCounter(validEntries, strict, delegate)
      case None => delegate
    }
}

//////////////////////////////////////
// Smoothing Implementation
//////////////////////////////////////

/**
 * CondFreqCounter decorator that smoothes counts.
 *
 * This class applies a very simple add-one smoothing procedure to the counts.
 *
 * @param lambda	smoothing parameter
 */
class SimpleSmoothingCondFreqCounter[A, B](lambda: Double, delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {

  protected def getDelegateResultCounts() = delegate.resultCounts

  override def resultCounts() = {
    val (delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = getDelegateResultCounts()

    // Compute MLE of B values alone (with add-one smoothing) for backoff
    val bigramCounts = delegateResultCounts.mapValuesStrict(_._1)
    val backoffCounts = amendBackoffCounts(bigramCounts.iterator.flatMap(_._2).groupByKey.mapValuesStrict(_.sum)) // Sum Bs across all As
    val smoothedBackoffCounts = backoffCounts.mapValuesStrict(_.toDouble + 1) // add-one smoothing
    val smoothedBackoffTotal = 1.0 + smoothedBackoffCounts.values.sum // add-one smoothing
    val backoffDist = smoothedBackoffCounts.mapValuesStrict(_ / smoothedBackoffTotal) // P(B) = C(B) / Sum[C(x) for all x]
      .withDefaultValue(1.0 / smoothedBackoffTotal) // for "unseen" B's, assume C(B) = 1

    val smoothedResultCounts =
      delegateResultCounts.mapValuesStrict {
        case (aCounts, aTotalAdd, aDefault) =>
          val singleCountItems = aCounts.count(_._2 <= 1.00000000001) // Count Bs occurring <= 1 time
          val smoothedLambda = lambda + singleCountItems
          val smoothedBackoff = backoffDist.mapValuesStrict(_ * smoothedLambda)
          val smoothedCounts = (smoothedBackoff.iterator ++ aCounts.mapValues(_.toDouble)).groupByKey.mapValuesStrict(_.sum)
          val totalAddition = 0.0
          val defaultCount = smoothedLambda / smoothedBackoffTotal
          (smoothedCounts, aTotalAdd + totalAddition, aDefault + defaultCount)
      }
    val totalAddition = 1.0
    val defaultCount = lambda / smoothedBackoffTotal
    (smoothedResultCounts, totalAddition + delegateTotalAddition.toDouble, defaultCount + delegateDefaultCount.toDouble)
  }

  protected def amendBackoffCounts(backoffCounts: Map[B, Double]) = backoffCounts
}

//////////////////////////////////////
// Add-delta smoothing implementation
//////////////////////////////////////

class AddDeltaSmoothingCondFreqCounter[A, B](delta: Double, delegate: CondFreqCounter[A, B]) extends DelegatingCondFreqCounter[A, B](delegate) {
  override def resultCounts() = {
    val (delegateResultCounts, delegateTotalAddition, delegateDefaultCount) = delegate.resultCounts
    (delegateResultCounts.mapValuesStrict { case (c, t, d) => (c, t + delta, d + delta) }, delegateTotalAddition + delta, delegateDefaultCount + delta)
  }
}

//////////////////////////////////////
// Factory
//////////////////////////////////////

/**
 * A factory for FreqCounter objects.  Exists so that procedures requiring
 * FreqCounters can create new ones at will.
 *
 * {{{
 *   new CondFreqCounterFactory {
 *     def get() = SimpleCondFreqCounter()
 *   }
 * }}}
 */
abstract class CondFreqCounterFactory[A, B] {
  def get(): CondFreqCounter[A, B]
  def get(initial: CondFreqCounts[A, B, Double]): CondFreqCounter[A, B] = get() ++= initial
}

object CondFreqCounterFactory {
  /**
   * Easily construct structured counter factory.
   *
   * apply("smooth" -> lambda, "const" -> grammar) => will smooth constrained counts
   * apply("const" -> grammar, "smooth" -> lambda) => will constrain smoothed counts
   */
  def apply[A, B](options: (String, Any)*) =
    new CondFreqCounterFactory[A, B] {
      def get() = CondFreqCounter(options: _*)
    }
}
